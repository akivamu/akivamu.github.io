---
layout: post
title: Java HashMap principle
date: '2017-01-18T23:09:00.002+07:00'
author: Huy Luu
tags:
- Java
modified_time: '2017-01-18T23:23:25.303+07:00'
thumbnail: https://4.bp.blogspot.com/-9LZiqwnI-Fg/WH9u6UGzbpI/AAAAAAAAEOk/w_f73mfrnlMohvaEnUUV3cmkFiXI3iFFACLcB/s72-c/hashmap-data-store.PNG
blogger_id: tag:blogger.com,1999:blog-2409403985918607624.post-6359981358096556878
blogger_orig_url: http://publicloop.blogspot.com/2017/01/java-hashmap-principle.html
---

Been learning Java for a while and using HashMap many times, but today I read an article about HashMap's buckets length and think I should dig deeper to understand it. This article is to summarize about HashMap, and how it works internally.<br /><br /><h2>Basic things about HashMap</h2>HashMap is an implementation of Map interface, basically is a map between KEYs and VALUEs.<br />HashMap mapping relied on hashing mechanism.<br /><br /><h2>How HashMap store data internally?</h2>HashMap stores data in an internal <b>array</b> (aka <b>table</b> or <b>buckets</b>) of type Entry.<br />Entry contains important properties: key and value. It also contains next pointer (will be discussed later)<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://4.bp.blogspot.com/-9LZiqwnI-Fg/WH9u6UGzbpI/AAAAAAAAEOk/w_f73mfrnlMohvaEnUUV3cmkFiXI3iFFACLcB/s1600/hashmap-data-store.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="173" src="https://4.bp.blogspot.com/-9LZiqwnI-Fg/WH9u6UGzbpI/AAAAAAAAEOk/w_f73mfrnlMohvaEnUUV3cmkFiXI3iFFACLcB/s400/hashmap-data-store.PNG" width="400" /></a></div>Above image describes data array with n elements. HashMap will increase capacity of this array when needed (discussed later).<br /><br /><h2>What happens when adding an entry to HashMap?</h2>This is what we do when add new entry to HashMap:<br /><pre class="prettyprint">// Suppose we have a HashMap<br />HashMap&lt;String, String&gt; infos;<br /><br />// We want to put this entry to HashMap<br />String key = "Name";<br />String value = "John";<br /><br />// So we have to call:<br />infos.put(key, value);<br /></pre>Here is what HashMap will do:<br /><br /><h3>Step 1. Calculate hash code</h3>HashMap will do hashing the key into an integer using <i>key.hashCode()</i>.<br />If key is null, its hash code will be 0.<br />Note that there are cases that different keys can have the same hash code (collision) that we will discuss below.<br /><br /><h3>Step 2. Find where to store data in Entry[] table</h3>Using above hash code, HashMap can calculate the position (index) in Entry[] table that can add value to.<br />Here is the formula (as <a href="http://stackoverflow.com/a/10879475/6445037" rel="nofollow" target="_blank">explained in SOF</a>):<br /><pre class="prettyprint">int index = hashcode &amp; table.length;<br /></pre><br /><h3>Step 3. Add Entry into table</h3>We can now build an Entry, with key and value. Then we set it to the index that calculated above:<br /><pre class="prettyprint">table[index] = entry;<br /></pre>Easy, huh?<br /><br /><h4>Solving hash code collision</h4>Now, remember the collision: when different keys have the same hash code. In this case, we have the same index too. How to store 2 or more entries into same table position?<br />We solve it by making a <b>LinkedList</b> of Entry! And set the head into Entry table, at the index we calculated.<br />Digging into Entry class source code, it contains properties: hashcode, key, value, and a pointer to another Entry - this is where we store the next Entry. And if there is 3rd Entry, we will store into the pointer in the 2nd Entry. And so on.<br /><br /><br /><h2>What happens when getting from HashMap?</h2>We now get the value by calling:<br /><pre class="prettyprint">String name = infos.get("Name");<br /></pre><br />Here is what HashMap will do:<br /><br /><h3>Step 1. Calculate hash code</h3>Same as when we put()<br /><br /><h3>Step 2. Find the index of stored entry</h3>Also using the same formula as when we put(), we can get the index that key supposed to store to.<br /><h3><br />Step 3. Getting the entry</h3>Just getting data from array table:<br /><pre class="prettyprint">Entry entry = table[index];<br /></pre>In case entry is null, then we just return null as normal.<br /><br />And now the fun part: remember in case of hash code collision, we put many values into HashMap which has the same hash code (so the index)?<br />Then how to get correct entry in that LinkedList?<br /><br /><h4>hashCode() and equals()</h4>We keep looping through that list, for each entry, we compare that entry's key with our key, using <b>equals()</b> function. If matched, we return the value, otherwise keep going until end of the linked list.<br />Now we can see the different in usage of <b>hashCode()</b> and <b>equals()</b>:<br /><ul><li>Key object’s hashCode() is required to calculate the index location of Entry object.</li><li>Key object’s equals() method is used to maintain uniqueness of Keys in map.</li></ul><br /><h2>The capacity of HashMap</h2>The <b>capacity </b>is the size of table (or length).<br />The <b>load factor</b> is a measure of how full the table is allowed to get before its capacity is automatically increased.<br />When HashMap's size (number of entries put into table) exceeds a <b>threshold</b> (is equals to <i>capacity * load factor</i>), internal data structures are rebuilt so that the table length has approximately doubled.<br /><br />