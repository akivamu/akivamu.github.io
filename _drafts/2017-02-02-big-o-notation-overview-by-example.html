---
layout: post
title: Big O notation overview by example
date: '2017-02-02T20:42:00.000+07:00'
author: Huy Luu
tags:
- Algorithm
modified_time: '2017-02-10T20:44:37.110+07:00'
blogger_id: tag:blogger.com,1999:blog-2409403985918607624.post-7794639147221474423
blogger_orig_url: http://publicloop.blogspot.com/2017/02/big-o-notation-overview-by-example.html
---

<a href="https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/" rel="nofollow" target="_blank">This</a> is great article of basic things about big O notation. Big O notation is used for describing the complexity of algorithm, or the cost of doing something in worst case. Just want to sum up here.<br /><br /><h2>O(1) - constant cost</h2>Doing something always costs the same constant amount of effort, no matter how difference input is. <br /><pre class="prettifyprint">bool IsFirstElementNull(IList&lt;string&gt; elements)<br />{<br />&nbsp; &nbsp; return elements[0] == null;<br />}</pre><h2><br />O(N) - linear cost</h2>Cost of algorithm linearly depends on size of input. <br /><pre class="prettifyprint">bool ContainsValue(IList&lt;string&gt; elements, string value)<br />{<br />&nbsp; &nbsp; foreach (var element in elements)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (element == value) return true;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; return false;<br />}</pre>In the best case, this algorithm takes 1 effort (comparison) to return result.<br />In the worst case, this algorithm takes n effort (length of array) to return result.<br />So it is O(N) <br /><br /><h2>O(N<sup>2</sup>)</h2><pre class="prettifyprint">bool ContainsDuplicates(IList&lt;string&gt; elements)<br />{<br />&nbsp; &nbsp; for (var outer = 0; outer &lt; elements.Count; outer++)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; for (var inner = 0; inner &lt; elements.Count; inner++)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Don't compare with self<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (outer == inner) continue;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (elements[outer] == elements[inner]) return true;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; return false;<br />}</pre><br />In the worst case, this algorithm takes n * n effort to return result.<br />It takes n iterations to go through all items in outer loop. For each iteration, need again go through all items in inner loop. It take n * n steps. So it is O(N<sup>2</sup>)<br /><br />Simple words:<br /><br /><ul><li>2 layers of loop: O(N<sup>2</sup>)</li><li>3 layers of loop: O(N<sup>3</sup>)</li><li>4 layers of loop: O(N<sup>4</sup>)</li><li>and so on</li></ul><br /><br /><h2>O(2<sup>n</sup>)</h2><pre class="prettifyprint">int test(int number)<br />{<br />&nbsp; &nbsp; if (number == 0) return number;<br /><br />&nbsp; &nbsp; return test(number - 1) + test(number - 1);<br />}</pre><br />Cost will doubles each time we increase size of data by 1. Because each step will call 2 function recursively:<br /><br /><ul><li>number = 0: 1 step (return expression)</li><li>number = 1: 2 steps i.e. 2 function calls test(0)</li><li>number = 2: 4 steps i.e. 2 function calls test(1), each has&nbsp;2 function calls test(0)</li><li>number = 3: 8 steps i.e. 2 function calls test (2), each has 2 test(1) and each has 2 test(0)</li></ul><br /><br /><h2>O(log(n))</h2>Quite hard to explain by word. Let's see this example from <a href="http://stackoverflow.com/questions/17122807/big-o-ologn-code-example" rel="nofollow" target="_blank">SOF</a>: <br /><pre class="prettifyprint">while (n &gt; 0) {<br />&nbsp; &nbsp;n/=2; <br />}</pre>Demonstration <br /><pre class="prettifyprint">Iteration | &nbsp; n<br />----------|--------<br />&nbsp; &nbsp; 0 &nbsp; &nbsp; | &nbsp; n<br />&nbsp; &nbsp; 1 &nbsp; &nbsp; | &nbsp;n/2<br />&nbsp; &nbsp; 2 &nbsp; &nbsp; | &nbsp;n/4<br />&nbsp; &nbsp;... &nbsp; &nbsp;| &nbsp;...<br />&nbsp; &nbsp;... &nbsp; &nbsp;| &nbsp;...<br />&nbsp; &nbsp; k &nbsp; &nbsp; | &nbsp;n/2^k</pre><br />2<sup>k</sup> = n -&gt; k = log(n)<br />So we have&nbsp;O(log(n))